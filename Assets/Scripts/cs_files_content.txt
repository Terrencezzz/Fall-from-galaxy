
--- Contents of C:\Users\Madhav Krishnan\Documents\GitHub\Fall-from-galaxy\Assets\Scripts\AnimationPlayer.cs ---

using UnityEngine;

public class AnimationPlayer : MonoBehaviour
{
    private Animator animator;
    private CharacterController characterController;

    public float walkSpeed = 2f;
    public float runSpeed = 5f;

    void Start()
    {
        animator = GetComponentInChildren<Animator>();
        characterController = GetComponent<CharacterController>();
    }

    void Update()
    {
        // Get input axes
        float moveX = Input.GetAxis("Horizontal");
        float moveZ = Input.GetAxis("Vertical");
        bool isJumping = Input.GetButtonDown("Jump");

        // Calculate movement speed
        Vector3 move = new Vector3(moveX, 0, moveZ);
        float speed = move.magnitude;

        // Determine if running
        bool isRunning = Input.GetKey(KeyCode.LeftShift);

        // Set animator parameters
        animator.SetFloat("Speed", speed);
        animator.SetBool("IsRunning", isRunning);
        animator.SetBool("IsJumping", !characterController.isGrounded);

        // Movement
        float currentSpeed = isRunning ? runSpeed : walkSpeed;
        Vector3 moveDirection = transform.forward * speed * currentSpeed * Time.deltaTime;
        characterController.Move(moveDirection);
    }
}



--- Contents of C:\Users\Madhav Krishnan\Documents\GitHub\Fall-from-galaxy\Assets\Scripts\BloaterBehaviour.cs ---

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;

public class BloaterBehaviour : MonoBehaviour, EnemyDamage
{
    // For navigation and pathfinding 
    private NavMeshAgent agent;
    private GameObject player;
    private Vector3 targetVector;
    public Vector3 startPoint;
    public Vector3 endPoint;
    private bool followPlayer = false;

    // For animation
    private Animator animator;
    public float speed;
    private Vector3 lastPosition;
    private float animationSpeed;

    // For combat 
    private int health = 15;
    public PlayerController playerController;

    // Start is called before the first frame update
    void Start()
    {
        animator = GetComponent<Animator>();
        agent = GetComponent<NavMeshAgent>();
        player = GameObject.FindGameObjectWithTag("Player");
        playerController = player.GetComponent<PlayerController>();
        lastPosition = transform.position;
        targetVector = endPoint;
    }

    // Update is called once per frame
    void Update()
    {
        // Death animation 
        if (health <= 0)
        {
            Die();
            animator.SetBool("Dead", true);
        }
        else
        {
            // Calculate speed for animation purposes
            float actualSpeed = Vector3.Distance(transform.position, lastPosition) / Time.deltaTime;
            animationSpeed = actualSpeed / speed;
            animator.SetFloat("Speed", animationSpeed);
            lastPosition = transform.position;

            // FOV code
            InFOV();

            // Navigation code
            if (followPlayer)
            {
                agent.destination = player.transform.position;
                float distance = Vector3.Distance(transform.position, player.transform.position);
                // Attack player if within 3 units 
                if (distance < 3f)
                {
                    // Attack player (if attack animation is not already being played)
                    if (!animator.GetCurrentAnimatorStateInfo(0).IsName("attack"))
                    {
                        agent.destination = transform.position; // Stop the NavMeshAgent
                        agent.isStopped = true;
                        animator.SetTrigger("Attack");
                        StartCoroutine(Wait());
                    }
                }
            }
            else
            {
                // If player not in range, continue patrol
                agent.destination = targetVector;
                float distance = Vector3.Distance(transform.position, targetVector);
                if (distance < 1f)
                {
                    targetVector = (targetVector == startPoint) ? endPoint : startPoint;
                }
            }
        }
    }

    void InFOV()
    {
        // Check player is in enemy FOV
        float distance = Vector3.Distance(transform.position, player.transform.position);
        if (distance < 7f)
        {
            followPlayer = true;
        }
        else
        {
            followPlayer = false;
        }
    }

    // Collision detection 
    public void TakeDamage()
    {
        health -= 1;
    }

    // Death logic 
    void Die()
    {
        // Stop navmesh
        agent.isStopped = true;
        speed = 0;
        // Stop physics interactions 
        Rigidbody rb = GetComponent<Rigidbody>();
        if (rb != null)
        {
            rb.isKinematic = true;
        }
        // Stop collisi
        GetComponent<Collider>().enabled = false;
    }

    // Basic wait coroutine
    IEnumerator Wait()
    {
        yield return new WaitForSeconds(2);
        float distance = Vector3.Distance(transform.position, player.transform.position);
        if (distance < 3f)
        {
            playerController.TakeDamage(5);
        }
        agent.isStopped = false;
    }
}


--- Contents of C:\Users\Madhav Krishnan\Documents\GitHub\Fall-from-galaxy\Assets\Scripts\CharacterControllerBase.cs ---

using UnityEngine;

public abstract class CharacterControllerBase : MonoBehaviour
{
    // Movement Settings
    public float walkSpeed;
    public float sprintSpeed;
    public float jumpHeight;

    // Flashlight Reference
    public Light flashlight;

    // Internal Variables
    protected CharacterController controller;
    protected Transform cameraTransform;
    protected float gravity = -19.81f;
    protected float yVelocity = 0f;

    // Control flag
    protected bool controlsEnabled = true;

    protected virtual void Start()
    {
        controller = GetComponent<CharacterController>();
        cameraTransform = GetComponentInChildren<Camera>().transform;

        if (flashlight == null)
            flashlight = GetComponentInChildren<Light>();
    }

    protected virtual void Update()
    {
        if (!controlsEnabled)
            return;

        MoveCharacter();
        HandleFlashlight();
    }

    protected abstract void MoveCharacter();

    protected virtual void HandleFlashlight()
    {
        if (Input.GetKeyDown(KeyCode.F))
            flashlight.enabled = !flashlight.enabled;
    }

    public virtual void EnableControl(bool enable)
    {
        controlsEnabled = enable;

        // Disable movement components
        var mouseLook = GetComponentInChildren<MouseLook>();
        if (mouseLook != null)
            mouseLook.enabled = enable;

        var animator = GetComponentInChildren<Animator>();
        if (animator != null)
            animator.enabled = enable;

        // Do not disable the camera or audio listener
        // This prevents errors when disabling controls
    }
}



--- Contents of C:\Users\Madhav Krishnan\Documents\GitHub\Fall-from-galaxy\Assets\Scripts\Checktutorial.cs ---

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;

public class Checktutorial : MonoBehaviour
{
    public InteractionController interactionController;
    // Start is called before the first frame update
    void Start()
    {
        
    }

    // Update is called once per frame
    void Update()
    {
        if (interactionController.robotCount == 1)
        {
            SceneManager.LoadScene(2);
        }
    }
}



--- Contents of C:\Users\Madhav Krishnan\Documents\GitHub\Fall-from-galaxy\Assets\Scripts\DoorRequirements.cs ---

using UnityEngine;

public class DoorRequirements : MonoBehaviour
{
    public int requiredRobots = 1;
    public int requiredNotes = 0;
}



--- Contents of C:\Users\Madhav Krishnan\Documents\GitHub\Fall-from-galaxy\Assets\Scripts\EnemyDamage.cs ---

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public interface EnemyDamage
{
    // Start is called before the first frame update
    public void TakeDamage();
}



--- Contents of C:\Users\Madhav Krishnan\Documents\GitHub\Fall-from-galaxy\Assets\Scripts\GameManager.cs ---

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using TMPro;

public class GameManager : MonoBehaviour
{
    public List<GameObject> characters = new List<GameObject>();
    private int currentCharacterIndex = 0;

    [Header("Lighting Settings")]
    public bool useAmbientLight = true;
    [ColorUsage(false, true)]
    public Color ambientLightColor = Color.white;

    public Material skyboxMaterial;
    public bool useSkybox = true;
    public bool useSkyboxAmbientLight = true;
    [Range(0f, 8f)]
    public float skyboxAmbientIntensity = 0f;

    [Range(0f, 8f)]
    public float sceneLightIntensity = 0f;
    [Range(0f, 8f)]
    public float flashlightIntensity = 1.0f;

    public GameObject robotPrefab; // Robot prefab for spawning

    // Message UI 
    [Header("Message UI")]
    public Canvas messageCanvas;
    public TextMeshProUGUI messageText;
    bool textDisplayed = false;

    public static GameManager Instance;

    // Reference to InteractionController
    private InteractionController interactionController;

    void Awake()
    {
        // Implement Singleton Pattern
        if (Instance == null)
        {
            Instance = this;
            DontDestroyOnLoad(gameObject); // Persist across scenes
        }
        else
        {
            Destroy(gameObject);
            return;
        }
    }

    void Start()
    {
        ApplyLightingSettings();
        InitializeCharacters();

        // Find the InteractionController in the scene
        interactionController = FindObjectOfType<InteractionController>();
        if (interactionController == null)
        {
            Debug.LogError("GameManager: InteractionController not found in the scene.");
        }

        // Ensure only the active character has AudioListener enabled
        UpdateAudioListeners();
    }

    void OnValidate()
    {
        ApplyLightingSettings();
    }

    void Update()
    {
        // Remove destroyed characters from the list
        CleanUpCharacters();

        // Switch character logic
        if (Input.GetKeyDown(KeyCode.Tab))
            SwitchCharacter();

        // Try to spawn robot
        if (Input.GetKeyDown(KeyCode.Q))
            TrySpawnRobot();

        // Toggle ambient light
        if (Input.GetKeyDown(KeyCode.L))
        {
            useAmbientLight = !useAmbientLight;
            ApplyLightingSettings();
        }
    }

    void ApplyLightingSettings()
    {
        if (useAmbientLight)
        {
            RenderSettings.ambientMode = UnityEngine.Rendering.AmbientMode.Flat;
            RenderSettings.ambientLight = ambientLightColor;
        }
        else if (useSkyboxAmbientLight && skyboxMaterial != null)
        {
            RenderSettings.ambientMode = UnityEngine.Rendering.AmbientMode.Skybox;
            RenderSettings.ambientIntensity = skyboxAmbientIntensity;
        }
        else
        {
            RenderSettings.ambientMode = UnityEngine.Rendering.AmbientMode.Flat;
            RenderSettings.ambientLight = Color.black;
        }

        RenderSettings.skybox = useSkybox ? skyboxMaterial : null;

        Light[] allLights = FindObjectsOfType<Light>();
        foreach (Light light in allLights)
        {
            light.intensity = IsFlashlight(light) ? flashlightIntensity : sceneLightIntensity;
        }
    }

    void InitializeCharacters()
    {
        PlayerController[] players = FindObjectsOfType<PlayerController>();
        RobotController[] robots = FindObjectsOfType<RobotController>();

        characters.Clear();
        characters.AddRange(System.Array.ConvertAll(players, p => p.gameObject));
        characters.AddRange(System.Array.ConvertAll(robots, r => r.gameObject));

        for (int i = 0; i < characters.Count; i++)
        {
            if (i == currentCharacterIndex)
                EnableControl(characters[i]);
            else
                DisableControl(characters[i]);
        }
    }

    void SwitchCharacter()
    {
        if (characters.Count <= 1)
            return;

        DisableControl(characters[currentCharacterIndex]);
        currentCharacterIndex = (currentCharacterIndex + 1) % characters.Count;

        // If the next character is a robot, ensure it's active
        if (characters[currentCharacterIndex].CompareTag("Robot"))
        {
            // You can add additional checks or initialization here if needed
        }

        EnableControl(characters[currentCharacterIndex]);

        // Update AudioListeners to ensure only active character has it enabled
        UpdateAudioListeners();
    }

    void TrySpawnRobot()
    {
        if (interactionController == null)
        {
            Debug.LogError("GameManager: InteractionController reference is missing.");
            return;
        }

        if (interactionController.robotCount <= 0)
        {
            Debug.Log("No robots available to deploy.");
            DisplayMessage("No robots available to deploy.");
            return;
        }

        GameObject player = characters[currentCharacterIndex];
        if (!player.CompareTag("Player") || !IsGroundFlat(player.transform.position))
        {
            Debug.Log("Cannot spawn robot here.");
            DisplayMessage("Cannot spawn robot here.");
            return;
        }

        if (FindSpawnPosition(player.transform.position, out Vector3 spawnPosition))
        {
            GameObject newRobot = Instantiate(robotPrefab, spawnPosition, Quaternion.identity);
            newRobot.tag = "Robot";

            // Initially disable the robot's control and AudioListener
            DisableControl(newRobot);

            // Add the new robot to the characters list
            characters.Add(newRobot);

            // Reduce the robot count in InteractionController
            interactionController.robotCount--;

            // Display "Robot deployed" message
            DisplayMessage("Robot deployed");
        }
        else
        {
            Debug.Log("No space to spawn robot.");
            DisplayMessage("No space to spawn robot.");
        }
    }

    void CleanUpCharacters()
    {
        // Remove any characters that have been destroyed
        characters.RemoveAll(item => item == null);

        // Ensure currentCharacterIndex is within bounds
        if (currentCharacterIndex >= characters.Count)
            currentCharacterIndex = 0;

        // If no characters left, handle accordingly
        if (characters.Count == 0)
        {
            Debug.LogWarning("No characters left in the game.");
        }
    }

    bool IsGroundFlat(Vector3 position)
    {
        if (Physics.Raycast(position, Vector3.down, out RaycastHit hit, 1f))
            return Vector3.Angle(hit.normal, Vector3.up) < 5f;
        return false;
    }

    bool FindSpawnPosition(Vector3 playerPosition, out Vector3 spawnPosition)
    {
        float spawnDistance = 5f;
        for (int i = 0; i < 8; i++)
        {
            Vector3 direction = Quaternion.Euler(0, i * 45, 0) * Vector3.forward;
            Vector3 checkPosition = playerPosition + direction * spawnDistance;
            if (IsPositionSuitable(checkPosition))
            {
                spawnPosition = checkPosition;
                return true;
            }
        }
        spawnPosition = Vector3.zero;
        return false;
    }

    bool IsPositionSuitable(Vector3 position)
    {
        if (!IsGroundFlat(position)) return false;
        return Physics.OverlapSphere(position, 0.5f).Length == 0;
    }

    void EnableControl(GameObject character)
    {
        ToggleCharacterComponents(character, true);
    }

    void DisableControl(GameObject character)
    {
        ToggleCharacterComponents(character, false);
    }

    void ToggleCharacterComponents(GameObject character, bool isEnabled)
    {
        var animator = character.GetComponentInChildren<Animator>();
        if (animator != null) animator.enabled = isEnabled;

        var playerController = character.GetComponent<PlayerController>();
        if (playerController != null) playerController.enabled = isEnabled;

        var robotController = character.GetComponent<RobotController>();
        if (robotController != null) robotController.enabled = isEnabled;

        var cam = character.GetComponentInChildren<Camera>();
        if (cam != null)
        {
            cam.enabled = isEnabled;
        }

        var audioListener = character.GetComponentInChildren<AudioListener>();
        if (audioListener != null)
        {
            audioListener.enabled = isEnabled;
        }

        var mouseLook = character.GetComponentInChildren<MouseLook>();
        if (mouseLook != null) mouseLook.enabled = isEnabled;
    }

    bool IsFlashlight(Light light)
    {
        foreach (var character in characters)
        {
            var characterLight = character.GetComponentInChildren<Light>();
            if (characterLight != null && characterLight == light)
                return true;
        }
        return false;
    }

    // Displays a message to the player
    void DisplayMessage(string message, float duration = 2f)
    {
        if (messageCanvas != null && messageText != null)
        {
            messageCanvas.enabled = true;
            messageText.text = message;
            CancelInvoke("HideMessage");
            Invoke("HideMessage", duration);
        }
    }

    void HideMessage()
    {
        if (messageCanvas != null)
            messageCanvas.enabled = false;
    }

    /// <summary>
    /// Updates AudioListeners to ensure only the active character has it enabled.
    /// </summary>
    void UpdateAudioListeners()
    {
        foreach (GameObject character in characters)
        {
            AudioListener listener = character.GetComponentInChildren<AudioListener>();
            if (listener != null)
            {
                listener.enabled = (character == characters[currentCharacterIndex]);
            }
        }
    }
}



--- Contents of C:\Users\Madhav Krishnan\Documents\GitHub\Fall-from-galaxy\Assets\Scripts\GunScript.cs ---

using UnityEngine;

public class GunScript : MonoBehaviour
{
    [Header("Gun Settings")]
    public float damage = 10f;
    public float range = 100f;
    public float fireRate = 0.1f;

    [Header("References")]
    public Camera fpsCam;
    public GameObject bulletHolePrefab;
    public GameObject bloodEffectPrefab;
    public AudioSource shootingSound;

    public GameObject autoGunPrefab;
    private GameObject currentGun;
    public PlayerController playerController;

    private float nextTimeToShoot = 0f;
    private int gunType = 1;  // 1 = Default gun, 2 = Auto gun
    public bool autoGunActive = true;

    public InteractionController interactionController;


    void Update()
    {
        HandleShooting();
        if (autoGunActive) HandleWeaponSwitching();
    }

    void HandleShooting()
    {
        if (Input.GetButton("Fire1") && Time.time >= nextTimeToShoot && gunType == 2 && interactionController.ammoCount > 0)
        {
            nextTimeToShoot = Time.time + fireRate;
            Shoot();
        }
    }

    void HandleWeaponSwitching()
    {
        if (Input.GetKeyDown(KeyCode.Alpha1))
        {
            SwitchGun(1);
        }
        else if (Input.GetKeyDown(KeyCode.Alpha2))
        {
            SwitchGun(2);
        }
    }

    void SwitchGun(int type)
    {
        if (type != gunType)
        {
            if (currentGun != null)
                Destroy(currentGun);
                gunType = type;
                playerController.isHand = true;

            if (type == 2 && autoGunActive)
            {
                currentGun = Instantiate(autoGunPrefab, transform.position, transform.rotation);
                currentGun.transform.SetParent(transform);
                gunType = type;
                playerController.isHand = false;
            }

            
        }
    }

    void Shoot()
    {
        if (shootingSound != null)
            shootingSound.Play();

        int layerMask = ~LayerMask.GetMask("Player");

        RaycastHit hit;
        if (Physics.Raycast(fpsCam.transform.position, fpsCam.transform.forward, out hit, range, layerMask))
        {
            //Debug.Log($"Hit: {hit.transform.name}");

            if (hit.collider.CompareTag("Enemy"))
            {
                EnemyDamage enemy = hit.collider.GetComponent<EnemyDamage>();
                enemy.TakeDamage();
                if (enemy != null)
                {
                    enemy.TakeDamage();
                    SpawnBloodEffect(hit);
                }
            }
            else
            {
                SpawnBulletHole(hit);
            }
        }

        interactionController.ammoCount--;
    }

    void SpawnBulletHole(RaycastHit hit)
    {
        if (bulletHolePrefab != null)
        {
            GameObject bulletHole = Instantiate(bulletHolePrefab, hit.point, Quaternion.LookRotation(hit.normal));
            bulletHole.transform.rotation *= Quaternion.Euler(0, 0, 90);
            Destroy(bulletHole, 5f);  // Destroy after 10 seconds to avoid clutter
        }
    }

    void SpawnBloodEffect(RaycastHit hit)
    {
        if (bloodEffectPrefab != null)
        {
            GameObject bloodEffect = Instantiate(bloodEffectPrefab, hit.point, Quaternion.LookRotation(hit.normal));
            Destroy(bloodEffect, 2f);  // Destroy after 2 seconds
        }
    }
}



--- Contents of C:\Users\Madhav Krishnan\Documents\GitHub\Fall-from-galaxy\Assets\Scripts\InteractionController.cs ---

using TMPro;
using UnityEngine;
using UnityEngine.SceneManagement;
using System.IO;
using System.Collections.Generic;

public class InteractionController : MonoBehaviour
{
    [Header("Interaction Settings")]
    public float interactDistance = 3f;
    public float sphereRadius = 0.5f;
    public LayerMask interactLayerMask;

    // UI Elements
    [Header("UI Elements")]
    public Canvas mainCanvas;
    public GameObject interactPrompt;               // The GameObject containing the prompt text
    public TextMeshProUGUI interactPromptText;      // The TextMeshPro component displaying the prompt
    public GameObject notePanel;                    // The panel that displays the note content
    public TextMeshProUGUI noteText;                // The TextMeshPro component displaying the note content
    public GameObject messagePanel;                 // The panel for displaying messages
    public TextMeshProUGUI messageText;             // The TextMeshPro component displaying messages

    // Internal variables
    private bool isReadingNote = false;
    private Camera cam;

    // Inventory counts
    [Header("Inventory")]
    public int robotCount = 0;
    public int noteCount = 0;
    public int ammoCount = 0;
    public bool hasGun = false;

    // Reference to GunScript
    private GunScript gunScript;

    // Door requirements
    [Header("Door Requirements")]
    public int requiredRobots = 0;
    public int requiredNotes = 0;

    // File path for Inventory.txt
    private string inventoryFilePath;

    void Awake()
    {
        // Initialize the inventory file path
        inventoryFilePath = Path.Combine(Application.streamingAssetsPath, "Inventory.txt");

        // Load inventory data
        LoadInventory();

        // Ensure that this GameObject persists across scenes
        DontDestroyOnLoad(gameObject);
    }

    void Start()
    {
        cam = GetComponentInChildren<Camera>();
        if (cam == null)
        {
            Debug.Log("InteractionController: Camera not found in children.");
        }

        // Ensure all UI elements are assigned
        if (mainCanvas == null)
            Debug.Log("InteractionController: MainCanvas is not assigned.");
        if (interactPrompt == null || interactPromptText == null)
            Debug.Log("InteractionController: InteractPrompt or its Text component is not assigned.");
        if (notePanel == null || noteText == null)
            Debug.Log("InteractionController: NotePanel or its Text component is not assigned.");
        if (messagePanel == null || messageText == null)
            Debug.Log("InteractionController: MessagePanel or its Text component is not assigned.");

        // Initially disable UI elements
        interactPrompt.SetActive(false);
        notePanel.SetActive(false);
        messagePanel.SetActive(false);

        // Get reference to GunScript
        gunScript = GetComponentInChildren<GunScript>();
        if (gunScript == null)
        {
            Debug.LogError("InteractionController: GunScript not found in children.");
        }
    }

    void Update()
    {
        if (isReadingNote)
        {
            if (Input.GetKeyDown(KeyCode.E))
                CloseNote();
            return;
        }

        Ray ray = new Ray(cam.transform.position, cam.transform.forward);
        RaycastHit hit;

        if (Physics.SphereCast(ray, sphereRadius, out hit, interactDistance, interactLayerMask))
        {
            GameObject hitObject = hit.collider.gameObject;
            string tag = hitObject.tag;

            switch (tag)
            {
                case "Robot":
                    ShowInteractPrompt("Press E to collect robot");
                    if (Input.GetKeyDown(KeyCode.E))
                        CollectRobot(hitObject);
                    break;

                case "Note":
                    ShowInteractPrompt("Press E to read note");
                    if (Input.GetKeyDown(KeyCode.E))
                        OpenNote(hitObject.GetComponent<Notes>(), hitObject);
                    break;

                case "AmmoCrate":
                    ShowInteractPrompt("Press E to collect ammo");
                    if (Input.GetKeyDown(KeyCode.E))
                        CollectAmmo(hitObject);
                    break;

                case "Gun":
                    ShowInteractPrompt("Press E to pick up gun");
                    if (Input.GetKeyDown(KeyCode.E))
                        CollectGun(hitObject);
                    break;

                case "Door":
                    ShowInteractPrompt("Press E to open door");
                    if (Input.GetKeyDown(KeyCode.E))
                        OpenDoor(hitObject);
                    break;

                case "Reactor":
                    ShowInteractPrompt("Press E to interact");
                    if (Input.GetKeyDown(KeyCode.E))
                        InteractWithReactor();
                    break;

                default:
                    HideInteractPrompt();
                    break;
            }
        }
        else
        {
            HideInteractPrompt();
        }
    }

    void ShowInteractPrompt(string message)
    {
        if (interactPrompt != null && interactPromptText != null)
        {
            interactPrompt.SetActive(true);
            interactPromptText.text = message;
        }
    }

    void HideInteractPrompt()
    {
        if (interactPrompt != null)
            interactPrompt.SetActive(false);
    }

    void CollectRobot(GameObject robot)
    {
        robotCount++;
        Destroy(robot);
        Debug.Log("Robot collected. Total robots: " + robotCount);
        DisplayMessage("Robot collected");
        UpdateInventoryCount("Robot", robotCount);
        SaveInventory();
    }

    void CollectAmmo(GameObject ammoCrate)
    {
        ammoCount += 10; // Assuming each crate gives 10 ammo
        Destroy(ammoCrate);
        Debug.Log("Ammo collected. Total ammo: " + ammoCount);
        DisplayMessage("Ammo collected");
        UpdateInventoryCount("Ammo", ammoCount);
        SaveInventory();
    }

    void OpenNote(Notes note, GameObject noteObject)
    {
        if (note == null)
        {
            Debug.LogError("InteractionController: Note component missing on the object.");
            return;
        }

        isReadingNote = true;

        if (notePanel != null && noteText != null)
        {
            notePanel.SetActive(true);
            noteText.text = note.noteContent;
        }

        HideInteractPrompt();

        // Disable player control
        var playerController = GetComponentInParent<CharacterControllerBase>();
        if (playerController != null)
            playerController.EnableControl(false);

        // Unlock cursor
        Cursor.lockState = CursorLockMode.None;
        Cursor.visible = true;

        // Destroy the note object (collecting it)
        noteCount++;
        Destroy(noteObject);
        UpdateInventoryCount("Note", noteCount);
        SaveInventory();
    }

    void CloseNote()
    {
        isReadingNote = false;

        if (notePanel != null)
            notePanel.SetActive(false);

        // Enable player control
        var playerController = GetComponentInParent<CharacterControllerBase>();
        if (playerController != null)
            playerController.EnableControl(true);

        // Lock cursor
        Cursor.lockState = CursorLockMode.Locked;
        Cursor.visible = false;

        // Display "Note collected" message
        DisplayMessage("Note collected", 2f);
    }

    void CollectGun(GameObject gunObject)
    {
        if (hasGun)
        {
            DisplayMessage("You already have a gun", 2f);
            return;
        }

        hasGun = true;

        if (gunScript != null)
        {
            gunScript.autoGunActive = true;
        }
        else
        {
            Debug.LogError("InteractionController: GunScript is null.");
        }

        Destroy(gunObject);
        Debug.Log("Gun collected.");
        DisplayMessage("Gun collected", 2f);
        SaveInventory();
    }

    void OpenDoor(GameObject doorObject)
    {
        // Door opening logic without using a Door class

        // Door requirements (can be set per door using custom properties or defaults)
        int doorRequiredRobots = requiredRobots;
        int doorRequiredNotes = requiredNotes;

        // Optionally, get custom requirements from the door object
        DoorRequirements doorReq = doorObject.GetComponent<DoorRequirements>();
        if (doorReq != null)
        {
            doorRequiredRobots = doorReq.requiredRobots;
            doorRequiredNotes = doorReq.requiredNotes;
        }

        // Check if player meets the requirements
        if (robotCount >= doorRequiredRobots && noteCount >= doorRequiredNotes)
        {
            // Open the door (e.g., destroy the door object or play an animation)
            Destroy(doorObject);
            DisplayMessage("Door opened", 2f);
        }
        else
        {
            string message = "Find ";

            if (robotCount < doorRequiredRobots)
                message += $"{doorRequiredRobots - robotCount} more robot(s) ";

            if (noteCount < doorRequiredNotes)
                message += $"{doorRequiredNotes - noteCount} more note(s) ";

            message += "to continue";

            DisplayMessage(message, 2f);
        }
    }

    void InteractWithReactor()
    {
        Debug.Log("Interacting with reactor...");
        DisplayMessage("Interacting with reactor...");
        // Load the next scene or perform other actions
        SceneManager.LoadScene("ReactorScene"); // Replace with your scene name
    }

    void DisplayMessage(string message, float duration = 2f)
    {
        if (messagePanel != null && messageText != null)
        {
            messagePanel.SetActive(true);
            messageText.text = message;
            CancelInvoke("HideMessage");
            Invoke("HideMessage", duration);
        }
    }

    void HideMessage()
    {
        if (messagePanel != null)
            messagePanel.SetActive(false);
    }

    void UpdateInventoryCount(string itemType, int count)
    {
        // Update your inventory UI or data here
        Debug.Log($"{itemType} count updated: {count}");
    }

    /// <summary>
    /// Saves the current inventory counts to Inventory.txt in StreamingAssets.
    /// </summary>
    void SaveInventory()
    {
        try
        {
            // Ensure the StreamingAssets directory exists
            if (!Directory.Exists(Application.streamingAssetsPath))
            {
                Directory.CreateDirectory(Application.streamingAssetsPath);
            }

            // Prepare the data to be written
            Dictionary<string, string> inventoryData = new Dictionary<string, string>
            {
                { "robotCount", robotCount.ToString() },
                { "noteCount", noteCount.ToString() },
                { "ammoCount", ammoCount.ToString() },
                { "hasGun", hasGun.ToString() }
            };

            // Write data to Inventory.txt
            using (StreamWriter writer = new StreamWriter(inventoryFilePath, false))
            {
                foreach (var entry in inventoryData)
                {
                    writer.WriteLine($"{entry.Key}={entry.Value}");
                }
            }

            Debug.Log("Inventory saved to " + inventoryFilePath);
        }
        catch (System.Exception ex)
        {
            Debug.LogError("Failed to save inventory: " + ex.Message);
        }
    }

    /// <summary>
    /// Loads the inventory counts from Inventory.txt in StreamingAssets.
    /// </summary>
    void LoadInventory()
    {
        try
        {
            if (File.Exists(inventoryFilePath))
            {
                using (StreamReader reader = new StreamReader(inventoryFilePath))
                {
                    string line;
                    while ((line = reader.ReadLine()) != null)
                    {
                        string[] splitData = line.Split('=');
                        if (splitData.Length == 2)
                        {
                            string key = splitData[0].Trim();
                            string value = splitData[1].Trim();

                            switch (key)
                            {
                                case "robotCount":
                                    int.TryParse(value, out robotCount);
                                    break;
                                case "noteCount":
                                    int.TryParse(value, out noteCount);
                                    break;
                                case "ammoCount":
                                    int.TryParse(value, out ammoCount);
                                    break;
                                case "hasGun":
                                    bool.TryParse(value, out hasGun);
                                    break;
                                default:
                                    Debug.LogWarning("Unknown key in Inventory.txt: " + key);
                                    break;
                            }
                        }
                    }
                }

                Debug.Log("Inventory loaded from " + inventoryFilePath);
            }
            else
            {
                Debug.Log("Inventory.txt not found. Starting with default inventory.");
                SaveInventory(); // Create the file with default values
            }
        }
        catch (System.Exception ex)
        {
            Debug.LogError("Failed to load inventory: " + ex.Message);
        }
    }

    // Optional: Method to reset inventory (useful for debugging)
    [ContextMenu("Reset Inventory")]
    void ResetInventory()
    {
        robotCount = 0;
        noteCount = 0;
        ammoCount = 0;
        hasGun = false;
        SaveInventory();
        Debug.Log("Inventory has been reset.");
    }
}



--- Contents of C:\Users\Madhav Krishnan\Documents\GitHub\Fall-from-galaxy\Assets\Scripts\MainCamera.cs ---

using UnityEngine;
using UnityEngine.SceneManagement;

public class MainCamera : MonoBehaviour
{
    public void PlayGame()
    {
        SceneManager.LoadSceneAsync(1);
    }

    public void QuitGame()
    {
        Application.Quit();
    }

    public void Restart()
    {

        SceneManager.LoadSceneAsync(1);
    }

    public void Restart1()
    {

        SceneManager.LoadSceneAsync(2);
    }

    public void Introduction()
    {
        SceneManager.LoadSceneAsync(4);
    }
}


--- Contents of C:\Users\Madhav Krishnan\Documents\GitHub\Fall-from-galaxy\Assets\Scripts\MessageTrigger.cs ---

// MessageTrigger.cs

using UnityEngine;

public class MessageTrigger : MonoBehaviour
{
    [Header("Message Settings")]
    [TextArea]
    public string messageText;
    public Color fontColor = Color.white;
    public int fontSize = 24;
    public Vector2 position = new Vector2(0.5f, 0.5f); // Normalized position (0 to 1)
    public float displayDuration = 5f; // Time to display the message

    private bool messageDisplayed = false;

    void OnTriggerEnter(Collider other)
    {
        if (messageDisplayed)
            return;

        if (other.CompareTag("Player"))
        {
            messageDisplayed = true;
            // GameManager.Instance.DisplayMessage(this);
        }
    }
}



--- Contents of C:\Users\Madhav Krishnan\Documents\GitHub\Fall-from-galaxy\Assets\Scripts\MouseLook.cs ---

using UnityEngine;

public class MouseLook : MonoBehaviour
{
    public float mouseSensitivity = 100f;

    Transform playerBody;
    float xRotation = 0f;

    void Start()
    {
        playerBody = transform.parent;
        Cursor.lockState = CursorLockMode.Locked; // Lock the cursor to the game window
    }

    void Update()
    {
        // Get mouse movement
        float mouseX = Input.GetAxis("Mouse X") * mouseSensitivity * Time.deltaTime;
        float mouseY = Input.GetAxis("Mouse Y") * mouseSensitivity * Time.deltaTime;

        // Rotate player body for horizontal movement
        playerBody.Rotate(Vector3.up * mouseX);

        // Rotate camera for vertical movement
        xRotation -= mouseY;
        xRotation = Mathf.Clamp(xRotation, -90f, 90f); // Limit vertical look
        transform.localRotation = Quaternion.Euler(xRotation, 0f, 0f);
    }
}



--- Contents of C:\Users\Madhav Krishnan\Documents\GitHub\Fall-from-galaxy\Assets\Scripts\Notes.cs ---

using UnityEngine;
using System.IO;

public class Notes : MonoBehaviour
{
    [Tooltip("Enter the name of the text file (including extension) located in Assets/Notes/")]
    public string textFileName;

    [TextArea]
    public string noteContent;

    void OnValidate()
    {
        LoadNoteContent();
    }

    void LoadNoteContent()
    {
        if (!string.IsNullOrEmpty(textFileName))
        {
            string path = Application.dataPath + "/Notes/" + textFileName;
            if (File.Exists(path))
            {
                noteContent = File.ReadAllText(path);
            }
            else
            {
                noteContent = "File not found at path: " + path;
            }
        }
    }
}



--- Contents of C:\Users\Madhav Krishnan\Documents\GitHub\Fall-from-galaxy\Assets\Scripts\PlayerController.cs ---

ï»¿using TMPro;
using UnityEngine;
using UnityEngine.SceneManagement;

public class PlayerController : CharacterControllerBase
{
    // Player Stats
    public int health = 200;
    public bool isHand = true;
    private bool stop = false;
    private int maxHealth = 200;

    [Header("UI Elements")]
    public TextMeshProUGUI healthText;
    public TextMeshProUGUI ammoText;
    public TextMeshProUGUI robotText;
    public TextMeshProUGUI noteText;

    public InteractionController interactionController;

    // Maximum values
    private int maxRobots = 3;
    private int maxNotes = 24;

    private void Start()
    {
        // Ensure health starts at maxHealth
        health = maxHealth;
        UpdateHealthUI(); // Update UI at the start
    }

    protected override void Update()
    {
        if (stop)
            return;

        base.Update();

        // Update UI elements
        UpdateHealthUI();
        UpdateAmmoUI();
        UpdateRobotUI();
        UpdateNoteUI();

        // Check for game over condition
        CheckGameOver();
    }

    protected override void MoveCharacter()
    {
        float moveX = Input.GetAxis("Horizontal");
        float moveZ = Input.GetAxis("Vertical");

        bool isSprinting = Input.GetKey(KeyCode.LeftShift) && isHand;
        float speed = isSprinting ? sprintSpeed : walkSpeed;

        Vector3 move = (cameraTransform.right * moveX + cameraTransform.forward * moveZ).normalized * speed;

        if (controller.isGrounded)
        {
            yVelocity = -0.5f;
            if (Input.GetButtonDown("Jump"))
                yVelocity = Mathf.Sqrt(jumpHeight * -2f * gravity);
        }
        else
        {
            yVelocity += gravity * Time.deltaTime;
        }

        move.y = yVelocity;
        controller.Move(move * Time.deltaTime);
    }

    private void OnTriggerEnter(Collider other)
    {
        if (other.CompareTag("Next"))
        {
            stop = true;
            SceneManager.LoadScene(SceneManager.GetActiveScene().buildIndex + 1);
        }
    }

    public void TakeDamage(int damage)
    {
        health -= damage;
        Debug.Log("Player health: " + health);
    }

    public void UpdateHealthUI()
    {
        if (healthText != null)
        {
            string heartEmoji = "â™¥";
            int barLength = 20; // Total number of '|' characters
            int filledLength = Mathf.Clamp(Mathf.CeilToInt((float)health / maxHealth * barLength), 0, barLength);
            string healthBar = new string('|', filledLength).PadRight(barLength, ' ');

            healthText.text = $"Health\n{heartEmoji} [{healthBar}] {health}/{maxHealth}";
        }
        else
        {
            Debug.LogWarning("HealthText UI element is not assigned.");
        }
    }

    public void UpdateAmmoUI()
    {
        if (ammoText != null && interactionController != null)
        {
            string ammoEmoji = "ðŸ”«";
            ammoText.text = $"Ammo\n{ammoEmoji} x {interactionController.ammoCount}";
        }
        else
        {
            Debug.LogWarning("AmmoText UI element or InteractionController is not assigned.");
        }
    }

    public void UpdateRobotUI()
    {
        if (robotText != null && interactionController != null)
        {
            string robotEmoji = "ðŸ¤–";
            int robotCount = interactionController.robotCount;

            // Build the robot slots
            string robotSlots = "<";
            for (int i = 0; i < maxRobots; i++)
            {
                robotSlots += i < robotCount ? "|" : " ";
            }
            robotSlots += ">";

            robotText.text = $"Robots\n{robotEmoji} {robotSlots}";
        }
        else
        {
            Debug.LogWarning("RobotText UI element or InteractionController is not assigned.");
        }
    }

    public void UpdateNoteUI()
    {
        if (noteText != null && interactionController != null)
        {
            string noteEmoji = "ðŸ“„";
            int barLength = 20; // Total number of '|' characters
            int filledLength = Mathf.Clamp(Mathf.CeilToInt((float)interactionController.noteCount / maxNotes * barLength), 0, barLength);
            string noteBar = new string('|', filledLength).PadRight(barLength, ' ');

            noteText.text = $"Notes\n{noteEmoji} [{noteBar}] {interactionController.noteCount}/{maxNotes}";
        }
        else
        {
            Debug.LogWarning("NoteText UI element or InteractionController is not assigned.");
        }
    }

    private void OnCollisionEnter(Collision collision)
    {
        if (collision.gameObject.CompareTag("Next"))
        {
            stop = true;
            int nextSceneIndex = SceneManager.GetActiveScene().buildIndex + 1;

            if (nextSceneIndex < SceneManager.sceneCountInBuildSettings)
            {
                SceneManager.LoadScene(nextSceneIndex);
            }
            else
            {
                Debug.Log("No more scenes to load.");
            }
        }
    }

    private void CheckGameOver()
    {
        if (health <= -200)
        {
            stop = true;
            Cursor.lockState = CursorLockMode.None;
            Cursor.visible = true;

            // Display glitchy "DEAD" text
            if (healthText != null)
            {
                string deadText = "DEAD";
                healthText.text = deadText;
            }

            // Delay before loading game over scene to allow player to see the "DEAD" text
            StartCoroutine(LoadGameOverSceneWithDelay(2f)); // 2-second delay
        }
    }

    private System.Collections.IEnumerator LoadGameOverSceneWithDelay(float delay)
    {
        yield return new WaitForSeconds(delay);
        SceneManager.LoadSceneAsync(3); // Ensure scene index 3 is correct
    }
}



--- Contents of C:\Users\Madhav Krishnan\Documents\GitHub\Fall-from-galaxy\Assets\Scripts\RobotController.cs ---

using UnityEngine;

public class RobotController : CharacterControllerBase
{
    protected override void MoveCharacter()
    {
        float moveX = Input.GetAxis("Horizontal");
        float moveZ = Input.GetAxis("Vertical");

        bool isSprinting = Input.GetKey(KeyCode.LeftShift);
        float speed = isSprinting ? sprintSpeed : walkSpeed;

        Vector3 move = (cameraTransform.right * moveX + cameraTransform.forward * moveZ).normalized * speed;

        if (controller.isGrounded)
        {
            yVelocity = -0.5f;
            if (Input.GetButtonDown("Jump"))
                yVelocity = Mathf.Sqrt(jumpHeight * -2f * gravity);
        }
        else
        {
            yVelocity += gravity * Time.deltaTime;
        }

        move.y = yVelocity;
        controller.Move(move * Time.deltaTime);
    }
}



--- Contents of C:\Users\Madhav Krishnan\Documents\GitHub\Fall-from-galaxy\Assets\Scripts\ShriekerBehaviour.cs ---

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class ShriekerBehaviour : MonoBehaviour
{
    // For navigation and pathfinding 
    private UnityEngine.AI.NavMeshAgent agent;
    private GameObject player;
    private Vector3 targetVector;
    public Vector3 startPoint;
    public Vector3 endPoint;
    private bool followPlayer = false;

    // For animation
    private Animator animator;
    public float speed;
    private Vector3 lastPosition;
    private float animationSpeed;

    // For combat 
    private int health = 15;
    public PlayerController playerController;

    // Start is called before the first frame update
    void Start()
    {
        animator = GetComponentInChildren<Animator>();
        agent = GetComponent<UnityEngine.AI.NavMeshAgent>();
        player = GameObject.FindGameObjectWithTag("Player");
        playerController = player.GetComponent<PlayerController>();
        lastPosition = transform.position;
        targetVector = endPoint;
    }

    // Update is called once per frame
    void Update()
    {
        // Death animation 
        if (health <= 0)
        {
            Die();
            animator.SetBool("Dead", true);
        }
        else
        {
            // Calculate speed for animation purposes
            float actualSpeed = Vector3.Distance(transform.position, lastPosition) / Time.deltaTime;
            animationSpeed = actualSpeed / speed;
            animator.SetFloat("Speed", animationSpeed);
            lastPosition = transform.position;

            // FOV code
            InFOV();

            // Navigation code
            if (followPlayer)
            {
                // Follows player (or robot) if within range
                agent.destination = player.transform.position;
                float distance = Vector3.Distance(transform.position, player.transform.position);
                // Attack player if within 3 units 
                if (distance < 3f)
                {
                    // Attack player (if attack animation is not already being played)
                    if (!animator.GetCurrentAnimatorStateInfo(0).IsName("Attack"))
                    {
                        agent.destination = transform.position; // Stop the NavMeshAgent
                        agent.isStopped = true;
                        animator.SetTrigger("Attack");
                        playerController.TakeDamage(20);
                    }
                }
                else
                {
                    agent.isStopped = false;
                }
            }
            else
            {
                // If player not in range, continue patrol
                agent.destination = targetVector;
                float distance = Vector3.Distance(transform.position, targetVector);
                if (distance < 1f)
                {
                    targetVector = (targetVector == startPoint) ? endPoint : startPoint;
                }
            }
        }
    }

    // Modified from other InFOV - follows the closest robot OR player entity
    void InFOV()
    {
        // Make an array of all objects in radius, find closest. this becomes the target
        float distance = Vector3.Distance(transform.position, player.transform.position);
        if (distance < 20f)
        {
            followPlayer = true;
        }
        else
        {
            followPlayer = false;
        }
    }

    // Collision detection 
    public void TakeDamage()
    {
        health -= 0;
    }

    // Death logic 
    void Die()
    {
        // Stop navmesh
        agent.isStopped = true;
        speed = 0;
        // Stop physics interactions 
        Rigidbody rb = GetComponent<Rigidbody>();
        if (rb != null)
        {
            rb.isKinematic = true;
        }
        // Stop collisi
        GetComponent<Collider>().enabled = false;
    }
}


--- Contents of C:\Users\Madhav Krishnan\Documents\GitHub\Fall-from-galaxy\Assets\Scripts\SpawnManager.cs ---

using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class SpawnManager : MonoBehaviour
{  
    // Enemy prefabs 
    public GameObject bloaterPrefab; // bloaters are fat and slow. Conversely, they deal and can take significant damage
    public GameObject stalkerPrefab; // stalkers are quiet and more persistent. they have larger 'patrol' areas and search for the player more thoroughly given their last location 
    public GameObject shriekerPrefab; // shreikers are large, fast, and loud. only known method of deterrence is to run, hide and pray. 

    // Enemy behaviour scripts 
    private BloaterBehaviour bloaterScript;
    private StalkerBehaviour stalkerScript;
    private ShriekerBehaviour shriekerScript;

    // Start is called before the first frame update
    void Start()
    {
        SpawnEnemy("bloater", new Vector3(46,0,42), new Vector3(31,0,28));
        SpawnEnemy("bloater", new Vector3(39,0,-6), new Vector3(21,0,-36));
        SpawnEnemy("bloater", new Vector3(51,0,-36), new Vector3(69,0,-54));
        SpawnEnemy("bloater", new Vector3(58,0,-24), new Vector3(45,0,-18));
        SpawnEnemy("bloater", new Vector3(15,0,-36), new Vector3(11,0,-43));
        SpawnEnemy("bloater", new Vector3(3,0,-25), new Vector3(11,0,-17));
        SpawnEnemy("bloater", new Vector3(-21,0,6), new Vector3(-39,0,-24));
        SpawnEnemy("bloater", new Vector3(-21,0,18), new Vector3(-21,0,60));
        SpawnEnemy("bloater", new Vector3(-57,0,5), new Vector3(-57,0,18));
        SpawnEnemy("bloater", new Vector3(-69,0,6), new Vector3(-81,0,19));
        SpawnEnemy("bloater", new Vector3(-3,0,30), new Vector3(15,0,48));
        SpawnEnemy("bloater", new Vector3(9,0,84), new Vector3(-27,0,78));
        SpawnEnemy("bloater", new Vector3(-45,0,60), new Vector3(-63,0,101));
        SpawnEnemy("bloater", new Vector3(-42,0,49), new Vector3(-48,0,35));
        SpawnEnemy("bloater", new Vector3(63,0,77), new Vector3(49,0,77));
        SpawnEnemy("bloater", new Vector3(58,0,63), new Vector3(40,0,60));
        SpawnEnemy("bloater", new Vector3(47,0,65), new Vector3(47,0,89));
        SpawnEnemy("bloater", new Vector3(-39,12,18), new Vector3(-3,12,0));
        SpawnEnemy("bloater", new Vector3(21,12,25), new Vector3(39,12,-36));
        SpawnEnemy("bloater", new Vector3(21,6,-36), new Vector3(39,6,-49));
        SpawnEnemy("bloater", new Vector3(48,-12,17), new Vector3(39,-12,18));
        SpawnEnemy("bloater", new Vector3(39,-12,20), new Vector3(40,-12,26));
        SpawnEnemy("bloater", new Vector3(38,-12,27), new Vector3(40,-12,37));
        SpawnEnemy("bloater", new Vector3(41,-12,47), new Vector3(47,-12,46));
        SpawnEnemy("bloater", new Vector3(59,-12,46), new Vector3(67,-12,48));
        SpawnEnemy("bloater", new Vector3(67,-12,41), new Vector3(69,-12,34));
        SpawnEnemy("bloater", new Vector3(69,-12,32), new Vector3(57,-12,27));
        SpawnEnemy("bloater", new Vector3(68,-12,17), new Vector3(59,-12,19));

        SpawnEnemy("stalker", new Vector3(-57,0,42), new Vector3(-10,0,83));
        SpawnEnemy("stalker", new Vector3(26,0,65), new Vector3(-21,0,23));
        SpawnEnemy("stalker", new Vector3(-63,0,11), new Vector3(-32,0,-25));
        SpawnEnemy("stalker", new Vector3(74,0,-6), new Vector3(68,0,-37));
        SpawnEnemy("stalker", new Vector3(39,6,-54), new Vector3(-4,12,36));
        SpawnEnemy("stalker", new Vector3(47,9,90), new Vector3(47,9,67));
        SpawnEnemy("stalker", new Vector3(32,4.6f,59), new Vector3(15,0,66));
        SpawnEnemy("stalker", new Vector3(69,-12,19), new Vector3(58,-12,48));
        SpawnEnemy("stalker", new Vector3(45,-12,48), new Vector3(47,-12,18));

        SpawnEnemy("shrieker", new Vector3(88,0,-8), new Vector3(-62,0,42));
        SpawnEnemy("shrieker", new Vector3(25,0,66), new Vector3(68,0,-54));
    }

    // Update is called once per frame
    void Update()
    {
        
    }
   
    // Spawns enemy 
    void SpawnEnemy(string enemyType, Vector3 startPoint, Vector3 endPoint) {
        if (enemyType == "bloater") {
            GameObject bloaterInstance = Instantiate(bloaterPrefab, startPoint, bloaterPrefab.transform.rotation);
            bloaterScript = bloaterInstance.GetComponent<BloaterBehaviour>();
            bloaterScript.startPoint = startPoint;
            bloaterScript.endPoint = endPoint;
        } else if (enemyType == "stalker") {
            GameObject stalkerInstance = Instantiate(stalkerPrefab, startPoint, stalkerPrefab.transform.rotation);
            stalkerScript = stalkerInstance.GetComponent<StalkerBehaviour>();
            stalkerScript.startPoint = startPoint;
            stalkerScript.endPoint = endPoint;  
        } else if (enemyType == "shrieker") {
            GameObject shriekerInstance = Instantiate(shriekerPrefab, startPoint, shriekerPrefab.transform.rotation);
            shriekerScript = shriekerInstance.GetComponent<ShriekerBehaviour>();
            stalkerScript.startPoint = startPoint;
            stalkerScript.endPoint = endPoint;  
        }
    }
}


--- Contents of C:\Users\Madhav Krishnan\Documents\GitHub\Fall-from-galaxy\Assets\Scripts\StalkerBehaviour.cs ---

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.AI;

public class StalkerBehaviour : MonoBehaviour, EnemyDamage
{
    // For navigation and pathfinding 
    private NavMeshAgent agent;
    private GameObject player;
    private Vector3 targetVector;
    public Vector3 startPoint;
    public Vector3 endPoint;
    private bool followPlayer = false;

    // For animation
    private Animator animator;
    public float speed;
    private Vector3 lastPosition;
    private float animationSpeed;

    // For combat 
    private int health = 5;
    public PlayerController playerController;

    // Start is called before the first frame update
    void Start()
    {
        animator = GetComponent<Animator>();
        agent = GetComponent<NavMeshAgent>();
        player = GameObject.FindGameObjectWithTag("Player");
        playerController = player.GetComponent<PlayerController>();
        lastPosition = transform.position;
        targetVector = endPoint;
    }

    // Update is called once per frame
    void Update()
    {
        // Death animation 
        if (health <= 0)
        {
            Die();
            animator.SetBool("Dead", true);
        }
        else
        {

            // If you want enemy to stand still, set 'IDLE' to true
            if (animator.GetBool("Idle"))
            {
                agent.isStopped = true;
            }

            // Calculate speed for animation purposes
            float actualSpeed = Vector3.Distance(transform.position, lastPosition) / Time.deltaTime;
            animationSpeed = actualSpeed / speed;
            animator.SetFloat("Speed", animationSpeed);
            lastPosition = transform.position;

            // FOV code
            InFOV();

            // Navigation code
            if (followPlayer)
            {
                agent.destination = player.transform.position;
                float distance = Vector3.Distance(transform.position, player.transform.position);
                // Attack player if within 3 units 
                if (distance < 3f)
                {
                    // Attack player (if attack animation is not already being played)
                    if (!animator.GetCurrentAnimatorStateInfo(0).IsName("attack"))
                    {
                        agent.destination = transform.position; // Stop the NavMeshAgent
                        agent.isStopped = true;
                        animator.SetTrigger("Attack");
                        StartCoroutine(Wait());
                    }
                }
            }
            else
            {
                // If player not in range, continue patrol
                agent.destination = targetVector;
                float distance = Vector3.Distance(transform.position, targetVector);
                if (distance < 1f)
                {
                    targetVector = (targetVector == startPoint) ? endPoint : startPoint;
                }
            }
        }
    }

    void InFOV()
    {
        // Check player is in enemy FOV
        float distance = Vector3.Distance(transform.position, player.transform.position);
        if (distance < 12f)
        {
            followPlayer = true;
        }
        else
        {
            followPlayer = false;
        }
    }

    // Collision detection 
    public void TakeDamage()
    {
        health -= 1;
    }

    // Death logic 
    void Die()
    {
        // Stop navmesh
        agent.isStopped = true;
        speed = 0;
        // Stop physics interactions
        Rigidbody rb = GetComponent<Rigidbody>();
        if (rb != null)
        {
            rb.isKinematic = true;
        }
        // Stop collisions
        GetComponent<Collider>().enabled = false;
    }

    // Basic wait coroutine
    IEnumerator Wait()
    {
        yield return new WaitForSeconds(2);
        float distance = Vector3.Distance(transform.position, player.transform.position);
        if (distance < 3f)
        {
            playerController.TakeDamage(10);
        }
        agent.isStopped = false;
    }
}


--- Contents of C:\Users\Madhav Krishnan\Documents\GitHub\Fall-from-galaxy\Assets\Scripts\TitleScreenScript.cs ---

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

public class TitleScreenScript : MonoBehaviour
{
    public GameObject buttonObject;
    public Button startButton;
    // Start is called before the first frame update
    void Start()
    {
        startButton.onClick.AddListener(ChangeScene);
    }

    // Update is called once per frame
    void Update()
    {
        
    }

    void ChangeScene() {
        // switch scenes
    }
}



--- Contents of C:\Users\Madhav Krishnan\Documents\GitHub\Fall-from-galaxy\Assets\Scripts\TutorialGameManager.cs ---

using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using TMPro;
using UnityEngine.SceneManagement;
using UnityEngine.UI;

public class TutorialGameManager : MonoBehaviour
{
    public List<GameObject> characters = new List<GameObject>();
    private int currentCharacterIndex = 0;

    [Header("Lighting Settings")]
    public bool useAmbientLight = true;
    [ColorUsage(false, true)]
    public Color ambientLightColor = Color.white;

    public Material skyboxMaterial;
    public bool useSkybox = true;
    public bool useSkyboxAmbientLight = true;
    [Range(0f, 8f)]
    public float skyboxAmbientIntensity = 0f;

    [Range(0f, 8f)]
    public float sceneLightIntensity = 0f;
    [Range(0f, 8f)]
    public float flashlightIntensity = 1.0f;

    public GameObject player;
    public GameObject robotPrefab; // Robot prefab for spawning

    // Message UI 
    [Header("Message UI")]
    public Canvas messageCanvas;
    public TextMeshProUGUI messageText;
    bool messageDisplayed = false;
    bool msg1 = false;
    bool msg2 = false;
    bool msg3 = false;
    bool msg4 = false;
    bool msg5 = false;
    bool msg6 = false;

    // For Doors 
    public GameObject closedDoorPrefab; // this needs to be dragged in from the actual scene, as we need its' position
    public GameObject openDoorPrefab; // this can be a regular open doorway prefab 
    public bool openDoor = false;

    public static TutorialGameManager Instance;

    void Awake()
    {
        if (Instance == null)
            Instance = this;
        else
            Destroy(gameObject);
    }

    void Start()
    {
        ApplyLightingSettings();
        InitializeCharacters();
    }

    void OnValidate()
    {
        ApplyLightingSettings();
    }

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Tab))
            SwitchCharacter();

        if (Input.GetKeyDown(KeyCode.Q))
            TrySpawnRobot();

        if (Input.GetKeyDown(KeyCode.L))
        {
            useAmbientLight = !useAmbientLight;
            ApplyLightingSettings();
        }
        // Opens the door 
        // set openDoor = true;
        if (openDoor)
            OpenDoor(closedDoorPrefab, openDoorPrefab); 

        DisplayTutorialMessages();
    }

    void ApplyLightingSettings()
    {
        if (useAmbientLight)
        {
            RenderSettings.ambientMode = UnityEngine.Rendering.AmbientMode.Flat;
            RenderSettings.ambientLight = ambientLightColor;
        }
        else if (useSkyboxAmbientLight && skyboxMaterial != null)
        {
            RenderSettings.ambientMode = UnityEngine.Rendering.AmbientMode.Skybox;
            RenderSettings.ambientIntensity = skyboxAmbientIntensity;
        }
        else
        {
            RenderSettings.ambientMode = UnityEngine.Rendering.AmbientMode.Flat;
            RenderSettings.ambientLight = Color.black;
        }

        RenderSettings.skybox = useSkybox ? skyboxMaterial : null;

        Light[] allLights = FindObjectsOfType<Light>();
        foreach (Light light in allLights)
        {
            light.intensity = IsFlashlight(light) ? flashlightIntensity : sceneLightIntensity;
        }
    }

    void InitializeCharacters()
    {
        PlayerController[] players = FindObjectsOfType<PlayerController>();
        RobotController[] robots = FindObjectsOfType<RobotController>();

        characters.Clear();
        characters.AddRange(System.Array.ConvertAll(players, p => p.gameObject));
        characters.AddRange(System.Array.ConvertAll(robots, r => r.gameObject));

        for (int i = 0; i < characters.Count; i++)
        {
            if (i == currentCharacterIndex)
                EnableControl(characters[i]);
            else
                DisableControl(characters[i]);
        }
    }

    void SwitchCharacter()
    {
        DisableControl(characters[currentCharacterIndex]);
        currentCharacterIndex = (currentCharacterIndex + 1) % characters.Count;
        EnableControl(characters[currentCharacterIndex]);
    }

    void TrySpawnRobot()
    {
        GameObject player = characters[currentCharacterIndex];
        if (!player.CompareTag("Player") || !IsGroundFlat(player.transform.position))
        {
            Debug.Log("Cannot spawn robot here.");
            return;
        }

        if (FindSpawnPosition(player.transform.position, out Vector3 spawnPosition))
        {
            GameObject newRobot = Instantiate(robotPrefab, spawnPosition, Quaternion.identity);
            characters.Add(newRobot);
        }
        else
        {
            Debug.Log("No space to spawn robot.");
        }
    }

    bool IsGroundFlat(Vector3 position)
    {
        if (Physics.Raycast(position, Vector3.down, out RaycastHit hit, 1f))
            return Vector3.Angle(hit.normal, Vector3.up) < 5f;
        return false;
    }

    bool FindSpawnPosition(Vector3 playerPosition, out Vector3 spawnPosition)
    {
        float spawnDistance = 5f;
        for (int i = 0; i < 8; i++)
        {
            Vector3 direction = Quaternion.Euler(0, i * 45, 0) * Vector3.forward;
            Vector3 checkPosition = playerPosition + direction * spawnDistance;
            if (IsPositionSuitable(checkPosition))
            {
                spawnPosition = checkPosition;
                return true;
            }
        }
        spawnPosition = Vector3.zero;
        return false;
    }

    bool IsPositionSuitable(Vector3 position)
    {
        if (!IsGroundFlat(position)) return false;
        return Physics.OverlapSphere(position, 0.5f).Length == 0;
    }

    // public void DisplayMessage(MessageTrigger messageTrigger)
    // {
    //     messageTextUI.text = messageTrigger.messageText;
    //     messageTextUI.color = messageTrigger.fontColor;
    //     messageTextUI.fontSize = messageTrigger.fontSize;

    //     RectTransform rectTransform = messageTextUI.GetComponent<RectTransform>();
    //     rectTransform.anchorMin = messageTrigger.position;
    //     rectTransform.anchorMax = messageTrigger.position;
    //     rectTransform.anchoredPosition = Vector2.zero;

    //     messageCanvas.enabled = true;
    //     StartCoroutine(HideMessageAfterDelay(messageTrigger.displayDuration));
    // }

    IEnumerator HideMessageAfterDelay(float delay)
    {
        yield return new WaitForSeconds(delay);
        messageCanvas.enabled = false;
    }

    void EnableControl(GameObject character)
    {
        ToggleCharacterComponents(character, true);
    }

    void DisableControl(GameObject character)
    {
        ToggleCharacterComponents(character, false);
    }

    void ToggleCharacterComponents(GameObject character, bool isEnabled)
    {
        var animator = character.GetComponentInChildren<Animator>();
        if (animator != null) animator.enabled = isEnabled;

        var playerController = character.GetComponent<PlayerController>();
        if (playerController != null) playerController.enabled = isEnabled;

        var robotController = character.GetComponent<RobotController>();
        if (robotController != null) robotController.enabled = isEnabled;

        var cam = character.GetComponentInChildren<Camera>();
        if (cam != null) cam.enabled = isEnabled;

        var audioListener = character.GetComponentInChildren<AudioListener>();
        if (audioListener != null) audioListener.enabled = isEnabled;

        var mouseLook = character.GetComponentInChildren<MouseLook>();
        if (mouseLook != null) mouseLook.enabled = isEnabled;
    }

    bool IsFlashlight(Light light)
    {
        foreach (var character in characters)
        {
            if (character.GetComponentInChildren<Light>() == light) return true;
        }
        return false;
    }

    // Writes given text to the HUD in a scolling manner 
    IEnumerator WriteText(string message) {
        messageDisplayed = true;
        for (int i = 0; i < message.Length; i++) {
            messageText.text += message[i];
            yield return new WaitForSeconds(0.05f);
        }
        yield return new WaitForSeconds(3f);
        messageText.text = "";
        messageDisplayed = false;
        Debug.Log("Flag =" + msg1);
    }

    IEnumerator Wait(float time) {
        yield return new WaitForSeconds(time);
    }

    // Event manager to display tutorial messages 
    void DisplayTutorialMessages() {
        if (!msg1 && !messageDisplayed) {
            StartCoroutine(WriteText("Lilith:\nHello, I am lilith, your sentient suit AI. Your vitals are looking stable, but you should take it slow. It has been a long trip, after all!"));
            msg1 = true;
        }
        if (msg1 && !msg2 && !messageDisplayed) {
            Wait(2);
            StartCoroutine(WriteText("Lilith:\nUse [W][A][S][D] to move.\nYou can toggle your flashlight with [F]. This docking bay looks quite empty - try explore the rest of the ship!"));
            msg2 = true;
        }
        if (msg2 && !msg3 && !messageDisplayed && player.transform.position.x < -12) {
            StartCoroutine(WriteText("Lilith:\nOh look! A drone! These can help investigate parts of the ship while you stay somewhere safe ... Who knows what could be lurking in these dark corridors.\nUse [E] to collect a drone, [Q] to deploy a drone, and [R] to switch between them."));
            msg3 = true;
        }
        if (msg3 && !msg4 && !messageDisplayed && player.transform.position.z > 45) {
            StartCoroutine(WriteText("Lilith:\nUse [SHIFT] to sprint!"));
            msg4 = true;
        }
        if (msg4 && !msg5 && !messageDisplayed && player.transform.position.z > 45) {
            StartCoroutine(WriteText("Lilith:\nThis catwalk looks a little worse for wear. Use [SPACE] to jump over this chasm!"));
            msg5 = true;
        }
        if (msg5 && !msg6 && !messageDisplayed && player.transform.position.z > 108 && player.transform.position.x < 0) {
            StartCoroutine(WriteText("Lilith:\nA console! Maybe we can use that to unlock this door ... I wonder what else these consoles can give us access to?"));
            msg6 = true;
        }
    }

    void OpenDoor(GameObject closed, GameObject open) 
    {
        Instantiate(open, closed.transform.position, closed.transform.rotation);
        Destroy(closed);
    }
}


